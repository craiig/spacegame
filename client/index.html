<script src="/jquery/jquery.min.js"></script>
<script src="/events.js"></script>
<script src="/network.js"></script>
<script src="/world.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="/three/three.min.js"></script>
<script src="/three/Tween.js"></script>
<script src="/three/Stats.js"></script>
<html>
<head>
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			a {
				color:#0078ff;
			}
		</style>
	</head>
<body>
<script>
	var container, stats;
	var camera, renderer, particle;
	var mouseX = 0, mouseY = 0;
	var currPing=0;
	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;
	var scene = new THREE.Scene();
	var lastUpdate=(new Date()).getTime();
	var updateTime=(new Date()).getTime();
	init();
	var material = new THREE.ParticleBasicMaterial( { map: new THREE.Texture( generateSprite() ), blending: THREE.AdditiveBlending } );
	var lastPing = 0;

	//var socket = io.connect('http://192.168.1.105:59473');
	var socket = io.connect(location.hostname); //better way
	var world = new World(socket);

	world.events.on("init", function(){ 
		console.log(world.WorldData)
		for (obj in world.WorldData){
			//var xobj = world.WorldData[obj];

			//probably a better way to identify object types than this
			if ((world.WorldData[obj].coords!==undefined)){
				world.WorldData[obj].particle = new THREE.Particle( material );

				initParticle(world.WorldData[obj].particle, world.WorldData[obj].coords,1);
				
				scene.add( world.WorldData[obj].particle);
				//console.log( world.WorldData[obj].particle.myPositionTween);
				//console.log(particle);
				//console.log(scene);
				//var objIndex=scene.__objects.indexOf(particle);
				//console.log(objIndex);
				world.WorldData[obj].prevCoord = world.WorldData[obj].coords; 	
				world.WorldData[obj].prevHeading = world.WorldData[obj].heading;
				//world.WorldData[obj].prevParticle = objIndex;
			} else if ((world.WorldData[obj].GameServerTime!==undefined)) {
				updateTime =  (new Date()).getTime() - lastUpdate;
				lastUpdate = (new Date()).getTime();
			}			
		}
	});

	world.events.on("update", function(){ 
		for (obj in world.WorldData){
			var xobj = world.WorldData[obj];
			
 			if ((xobj.GameServerTime!==undefined))		{
				updateTime =  Date.now() - lastUpdate;
				lastUpdate = Date.now();
			} 
			else
				if (xobj.coords!== undefined){
				//particle = scene.__objects[xobj.prevParticle];
				//console.log(updateTime);
				setParticle( xobj.particle, updateTime, xobj.prevCoord, xobj.coords,xobj.heading[0]/10);
				// console.log('Pos tween');
				// console.log(xobj.particle.myPositionTween);
				// console.log('Scale tween');
				// console.log(xobj.particle.myScaleTween);
				//xobj.particle.myPositionTween.start();
				//xobj.particle.myScaleTween.start();
				world.WorldData[obj].prevCoord = xobj.coords; 	
				world.WorldData[obj].prevHeading = xobj.heading;
			} 
		}
	});

	function initParticle( particle, coords, newScale) {
		particle.position.x = new Number(coords[0]);
		particle.position.y = new Number(coords[1]);
		particle.scale.x = particle.scale.y = newScale;
		particle.myPositionTween = new TWEEN.Tween( particle.position )
			.to( { x: new Number(coords[0]*2), y: new Number(coords[1]*2)}, 1000 )
			.onUpdate (function () {
					console.log('boopp');
					return this;
			});	

		particle.myScaleTween= new TWEEN.Tween( particle.scale )
		 	.to( { x: newScale, y: newScale }, 0 );
		// console.log(particle.myPositionTween);	
	}

	function setParticle( particle, time, coordsFrom,coordsTo, newScale) {
		//particle.myPositionTween.stop();
		//particle.myScaleTween.stop();

		//particle.position.x = new Number(coordsFrom[0]);
		//particle.position.y = new Number(coordsFrom[1]);
		// console.log(particle.myPositionTween._duration);
		// particle.myPositionTween.to({ x: coordsTo[0], y: coordsTo[1]}, time ) ;
		// particle.myPositionTween.start();
		// //particle.myScaleTween.to({ x: newScale, y: newScale }, time ) ;
		//console.log(particle.myPositionTween);	
	
		particle.myPositionTween =new TWEEN.Tween( particle.position)
		//console.log(particle.myPositionTween);
		//particle.myPositionTween.Tween(particle.position);

		.to(  { x: coordsTo[0], y: coordsTo[1]}, time )
		.start();
		//);
//particle.myPositionTween.start();	

		//particle.myPositionTween.start();	
		//TWEEN.add(particle.myPositionTween);
			// .onUpdate (function () {
			// 		console.log('beep');
			// })
			//.start();
			//console.log(q);
		 particle.myScaleTween= new TWEEN.Tween( particle.scale )
		  	.to( { x: newScale, y: newScale }, time )
		  	.start();
		//  	.start();


		// particle.myPositionTween.to = function () {
		// 	_duration = time;
		// 	_valuesEnd = { x: coordsTo[0], y: coordsTo[1]};
		// 	return this;
		// };
		// console.log(particle.myPositionTween);
		//  particle.myPositionTween._duration = time;
		//  particle.myPositionTween._valuesEnd = { x: coordsTo[0], y: coordsTo[1]};
		// //particle.myPositionTween.start();
		 // particle.myScaleTween._duration = time;
		 // particle.myScaleTween._valuesEnd = { x: newScale, y: newScale };
		// particle.myPositionTween.onUpdate = function() {
		// 	console.log(particle.position.x);
		// }
		
	}

	function generateSprite() {
		var canvas = document.createElement( 'canvas' );
		canvas.width = 16;
		canvas.height = 16;

		var context = canvas.getContext( '2d' );
		var gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );
		gradient.addColorStop( 0, 'rgba(255,255,255,1)' );
		gradient.addColorStop( 0.2, 'rgba(0,255,255,1)' );
		gradient.addColorStop( 0.4, 'rgba(0,0,64,1)' );
		gradient.addColorStop( 1, 'rgba(0,0,0,1)' );

		context.fillStyle = gradient;
		context.fillRect( 0, 0, canvas.width, canvas.height );

		return canvas;

	}
	function init() {
		container = document.createElement( 'div' );
		document.body.appendChild( container );

		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 5000 );
		camera.position.z = 100;

		//renderer = new THREE.WebGLRenderer();
		renderer = new THREE.CanvasRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.sortElements = false;
		renderer.setClearColorHex( 0x0000ff, 0.25 );
		container.appendChild( renderer.domElement );

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild( stats.domElement );

		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'touchstart', onDocumentTouchStart, false );
		document.addEventListener( 'touchmove', onDocumentTouchMove, false );

		//

		//window.addEventListener( 'resize', onWindowResize, false );

	}

	function animate() {
		requestAnimationFrame( animate );
		render();
		stats.update();
	}

	function render() {

		TWEEN.update();

		camera.position.x += ( mouseX - camera.position.x ) * 0.05;
		camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
		camera.lookAt( scene.position );

		renderer.render( scene, camera );

	}


	function onDocumentMouseMove( event ) {
		mouseX = event.clientX - windowHalfX;
		mouseY = event.clientY - windowHalfY;
	}

	function onDocumentTouchStart( event ) {
		if ( event.touches.length == 1 ) {
			event.preventDefault();
			mouseX = event.touches[ 0 ].pageX - windowHalfX;
			mouseY = event.touches[ 0 ].pageY - windowHalfY;
		}
	}

	function onDocumentTouchMove( event ) {
		if ( event.touches.length == 1 ) {
			event.preventDefault();
			mouseX = event.touches[ 0 ].pageX - windowHalfX;
			mouseY = event.touches[ 0 ].pageY - windowHalfY;
		}
	}



	//example: send a network obj rpc for testing
	world.socket.emit("network_objrpc", {objid:1,eventname:'attach_to_ship'});

	//send ping back immediately since we'll block processing and we can use it to measure how long this takes
	this.world.socket.emit('ping', { time: (new Date()).getTime() });

	//setup simple ping function
	$(document).ready( function(){ //fire when the document dom is ready
	socket.on('ping', function(data){
	//console.log("ping response:");
	//console.log(data);
	var now = (new Date()).getTime();
	$("#ping").html(now - data.time);
	//console.log("now: " + now + " received: " + data.time)
	lastPing = now - data.time;
	//this.emit('ping', { time: now });
	})
	})

	//setup a keypress handler
	$(document).bind('keydown', function(e){
	if(e.which == 38){
	//up key
	socket.emit('ship_accelerate_down');
	//console.log("down")
	} else if(e.which == 40){
	//down key
	} else if(e.which == 37){
	//left
	socket.emit('ship_accelerate_left');
	} else if(e.which == 39){
	//right
	socket.emit('ship_accelerate_right');
	}
	//console.log(e.which);
	})

	$(document).bind('keyup', function(e){
	if(e.which == 38){
	//up key
	socket.emit('ship_accelerate_up', "0")
	//console.log("up")
	} else if(e.which == 40){
	//down key
	} else if(e.which == 37){
	//left
	} else if(e.which == 39){
	//right
	}
	//console.log(e.which);
	})




	animate();



</script> 

Ping: <span id="ping">xx</span> ms
<br/>
<br/>
Ships: <ul id="shiplist"></ul>
<br/>
<br/>
Name: <input type="text" /> <br />
Players: <ul id="playerlist"></ul>

</body>
</html>